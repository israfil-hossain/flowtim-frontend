"use client";
import {
  createEmitter,
  debounce,
  debounceController,
  debug,
  defaultRateLimit,
  error,
  globalThrottleQueue,
  renderQueryString,
  throttle,
  useAdapter,
  useAdapterDefaultOptions,
  useAdapterProcessUrlSearchParams,
  warn
} from "./chunk-52OHABRI.js";
import {
  require_react
} from "./chunk-EGKDWVYF.js";
import {
  __toESM
} from "./chunk-WOOG5QLI.js";

// node_modules/.pnpm/nuqs@2.6.0_react-router-dom@7.9.3_react-dom@18.3.1_react@18.3.1__react@18.3.1__react-ro_2c608c5120377f1a6705390e68075f8e/node_modules/nuqs/dist/index.js
var import_react = __toESM(require_react());
function createLoader(parsers, { urlKeys = {} } = {}) {
  function loadSearchParams(input, { strict = false } = {}) {
    if (input instanceof Promise) return input.then((i) => loadSearchParams(i, { strict }));
    const searchParams = extractSearchParams(input);
    const result = {};
    for (const [key, parser] of Object.entries(parsers)) {
      const urlKey = urlKeys[key] ?? key;
      const query = searchParams.get(urlKey);
      if (query === null) {
        result[key] = parser.defaultValue ?? null;
        continue;
      }
      let parsedValue;
      try {
        parsedValue = parser.parse(query);
      } catch (error$1) {
        if (strict) throw new Error(`[nuqs] Error while parsing query \`${query}\` for key \`${key}\`: ${error$1}`);
        parsedValue = null;
      }
      if (strict && query && parsedValue === null) throw new Error(`[nuqs] Failed to parse query \`${query}\` for key \`${key}\` (got null)`);
      result[key] = parsedValue ?? parser.defaultValue ?? null;
    }
    return result;
  }
  return loadSearchParams;
}
function extractSearchParams(input) {
  try {
    if (input instanceof Request) return input.url ? new URL(input.url).searchParams : new URLSearchParams();
    if (input instanceof URL) return input.searchParams;
    if (input instanceof URLSearchParams) return input;
    if (typeof input === "object") {
      const searchParams = new URLSearchParams();
      for (const [key, value] of Object.entries(input)) if (Array.isArray(value)) for (const v of value) searchParams.append(key, v);
      else if (value !== void 0) searchParams.set(key, value);
      return searchParams;
    }
    if (typeof input === "string") {
      if (URL.hasOwnProperty("canParse") && URL.canParse(input)) return new URL(input).searchParams;
      return new URLSearchParams(input);
    }
  } catch {
  }
  return new URLSearchParams();
}
function safeParse(parser, value, key) {
  try {
    return parser(value);
  } catch (error$1) {
    warn("[nuqs] Error while parsing value `%s`: %O" + (key ? " (for key `%s`)" : ""), value, error$1, key);
    return null;
  }
}
function createParser(parser) {
  function parseServerSideNullable(value) {
    if (typeof value === "undefined") return null;
    let str = "";
    if (Array.isArray(value)) {
      if (value[0] === void 0) return null;
      str = value[0];
    }
    if (typeof value === "string") str = value;
    return safeParse(parser.parse, str);
  }
  return {
    eq: (a, b) => a === b,
    ...parser,
    parseServerSide: parseServerSideNullable,
    withDefault(defaultValue) {
      return {
        ...this,
        defaultValue,
        parseServerSide(value) {
          return parseServerSideNullable(value) ?? defaultValue;
        }
      };
    },
    withOptions(options) {
      return {
        ...this,
        ...options
      };
    }
  };
}
var parseAsString = createParser({
  parse: (v) => v,
  serialize: String
});
var parseAsInteger = createParser({
  parse: (v) => {
    const int = parseInt(v);
    return int == int ? int : null;
  },
  serialize: (v) => "" + Math.round(v)
});
var parseAsIndex = createParser({
  parse: (v) => {
    const int = parseInt(v);
    return int == int ? int - 1 : null;
  },
  serialize: (v) => "" + Math.round(v + 1)
});
var parseAsHex = createParser({
  parse: (v) => {
    const int = parseInt(v, 16);
    return int == int ? int : null;
  },
  serialize: (v) => {
    const hex = Math.round(v).toString(16);
    return (hex.length & 1 ? "0" : "") + hex;
  }
});
var parseAsFloat = createParser({
  parse: (v) => {
    const float = parseFloat(v);
    return float == float ? float : null;
  },
  serialize: String
});
var parseAsBoolean = createParser({
  parse: (v) => v === "true",
  serialize: String
});
function compareDates(a, b) {
  return a.valueOf() === b.valueOf();
}
var parseAsTimestamp = createParser({
  parse: (v) => {
    const ms = parseInt(v);
    return ms == ms ? new Date(ms) : null;
  },
  serialize: (v) => "" + v.valueOf(),
  eq: compareDates
});
var parseAsIsoDateTime = createParser({
  parse: (v) => {
    const date = new Date(v);
    return date.valueOf() == date.valueOf() ? date : null;
  },
  serialize: (v) => v.toISOString(),
  eq: compareDates
});
var parseAsIsoDate = createParser({
  parse: (v) => {
    const date = new Date(v.slice(0, 10));
    return date.valueOf() == date.valueOf() ? date : null;
  },
  serialize: (v) => v.toISOString().slice(0, 10),
  eq: compareDates
});
function parseAsStringEnum(validValues) {
  return parseAsStringLiteral(validValues);
}
function parseAsStringLiteral(validValues) {
  return createParser({
    parse: (query) => {
      const asConst = query;
      return validValues.includes(asConst) ? asConst : null;
    },
    serialize: String
  });
}
function parseAsNumberLiteral(validValues) {
  return createParser({
    parse: (query) => {
      const asConst = parseFloat(query);
      if (validValues.includes(asConst)) return asConst;
      return null;
    },
    serialize: String
  });
}
function parseAsJson(validator) {
  return createParser({
    parse: (query) => {
      try {
        const obj = JSON.parse(query);
        if ("~standard" in validator) {
          const result = validator["~standard"].validate(obj);
          if (result instanceof Promise) throw new Error("[nuqs] Only synchronous Standard Schemas are supported in parseAsJson.");
          return result.issues ? null : result.value;
        }
        return validator(obj);
      } catch {
        return null;
      }
    },
    serialize: (value) => JSON.stringify(value),
    eq(a, b) {
      return a === b || JSON.stringify(a) === JSON.stringify(b);
    }
  });
}
function parseAsArrayOf(itemParser, separator = ",") {
  const itemEq = itemParser.eq ?? ((a, b) => a === b);
  const encodedSeparator = encodeURIComponent(separator);
  return createParser({
    parse: (query) => {
      if (query === "") return [];
      return query.split(separator).map((item, index) => safeParse(itemParser.parse, item.replaceAll(encodedSeparator, separator), `[${index}]`)).filter((value) => value !== null && value !== void 0);
    },
    serialize: (values) => values.map((value) => {
      const str = itemParser.serialize ? itemParser.serialize(value) : String(value);
      return str.replaceAll(separator, encodedSeparator);
    }).join(separator),
    eq(a, b) {
      if (a === b) return true;
      if (a.length !== b.length) return false;
      return a.every((value, index) => itemEq(value, b[index]));
    }
  });
}
function createSerializer(parsers, { clearOnDefault = true, urlKeys = {}, processUrlSearchParams } = {}) {
  function serialize(arg1BaseOrValues, arg2values = {}) {
    let [base, search] = isBase(arg1BaseOrValues) ? splitBase(arg1BaseOrValues) : ["", new URLSearchParams()];
    const values = isBase(arg1BaseOrValues) ? arg2values : arg1BaseOrValues;
    if (values === null) {
      for (const key in parsers) {
        const urlKey = urlKeys[key] ?? key;
        search.delete(urlKey);
      }
      if (processUrlSearchParams) search = processUrlSearchParams(search);
      return base + renderQueryString(search);
    }
    for (const key in parsers) {
      const parser = parsers[key];
      const value = values[key];
      if (!parser || value === void 0) continue;
      const urlKey = urlKeys[key] ?? key;
      const isMatchingDefault = parser.defaultValue !== void 0 && (parser.eq ?? ((a, b) => a === b))(value, parser.defaultValue);
      if (value === null || (parser.clearOnDefault ?? clearOnDefault ?? true) && isMatchingDefault) search.delete(urlKey);
      else search.set(urlKey, parser.serialize(value));
    }
    if (processUrlSearchParams) search = processUrlSearchParams(search);
    return base + renderQueryString(search);
  }
  return serialize;
}
function isBase(base) {
  return typeof base === "string" || base instanceof URLSearchParams || base instanceof URL;
}
function splitBase(base) {
  if (typeof base === "string") {
    const [path = "", ...search] = base.split("?");
    return [path, new URLSearchParams(search.join("?"))];
  } else if (base instanceof URLSearchParams) return ["", new URLSearchParams(base)];
  else return [base.origin + base.pathname, new URLSearchParams(base.searchParams)];
}
function createStandardSchemaV1(parsers, { urlKeys, partialOutput = false } = {}) {
  const serialize = createSerializer(parsers, { urlKeys });
  const load = createLoader(parsers, { urlKeys });
  return { "~standard": {
    version: 1,
    vendor: "nuqs",
    validate(input) {
      try {
        const url = serialize(input);
        const value = load(url, { strict: true });
        if (partialOutput) {
          for (const key in value) if (!(key in input)) delete value[key];
        }
        return { value };
      } catch (error$1) {
        return { issues: [{ message: error$1 instanceof Error ? error$1.message : String(error$1) }] };
      }
    }
  } };
}
var emitter = createEmitter();
var defaultUrlKeys = {};
function useQueryStates(keyMap, options = {}) {
  const hookId = (0, import_react.useId)();
  const defaultOptions = useAdapterDefaultOptions();
  const processUrlSearchParams = useAdapterProcessUrlSearchParams();
  const { history = "replace", scroll = (defaultOptions == null ? void 0 : defaultOptions.scroll) ?? false, shallow = (defaultOptions == null ? void 0 : defaultOptions.shallow) ?? true, throttleMs = defaultRateLimit.timeMs, limitUrlUpdates = defaultOptions == null ? void 0 : defaultOptions.limitUrlUpdates, clearOnDefault = (defaultOptions == null ? void 0 : defaultOptions.clearOnDefault) ?? true, startTransition: startTransition$1, urlKeys = defaultUrlKeys } = options;
  const stateKeys = Object.keys(keyMap).join(",");
  const resolvedUrlKeys = (0, import_react.useMemo)(() => Object.fromEntries(Object.keys(keyMap).map((key) => [key, urlKeys[key] ?? key])), [stateKeys, JSON.stringify(urlKeys)]);
  const adapter = useAdapter(Object.values(resolvedUrlKeys));
  const initialSearchParams = adapter.searchParams;
  const queryRef = (0, import_react.useRef)({});
  const defaultValues = (0, import_react.useMemo)(() => Object.fromEntries(Object.keys(keyMap).map((key) => [key, keyMap[key].defaultValue ?? null])), [Object.values(keyMap).map(({ defaultValue }) => defaultValue).join(",")]);
  const queuedQueries = debounceController.useQueuedQueries(Object.values(resolvedUrlKeys));
  const [internalState, setInternalState] = (0, import_react.useState)(() => {
    const source = initialSearchParams ?? new URLSearchParams();
    return parseMap(keyMap, urlKeys, source, queuedQueries).state;
  });
  const stateRef = (0, import_react.useRef)(internalState);
  debug("[nuq+ %s `%s`] render - state: %O, iSP: %s", hookId, stateKeys, internalState, initialSearchParams);
  if (Object.keys(queryRef.current).join("&") !== Object.values(resolvedUrlKeys).join("&")) {
    const { state, hasChanged } = parseMap(keyMap, urlKeys, initialSearchParams, queuedQueries, queryRef.current, stateRef.current);
    if (hasChanged) {
      debug("[nuq+ %s `%s`] State changed: %O", hookId, stateKeys, {
        state,
        initialSearchParams,
        queuedQueries,
        queryRef: queryRef.current,
        stateRef: stateRef.current
      });
      stateRef.current = state;
      setInternalState(state);
    }
    queryRef.current = Object.fromEntries(Object.values(resolvedUrlKeys).map((urlKey) => [urlKey, (initialSearchParams == null ? void 0 : initialSearchParams.get(urlKey)) ?? null]));
  }
  (0, import_react.useEffect)(() => {
    const { state, hasChanged } = parseMap(keyMap, urlKeys, initialSearchParams, queuedQueries, queryRef.current, stateRef.current);
    if (hasChanged) {
      debug("[nuq+ %s `%s`] State changed: %O", hookId, stateKeys, {
        state,
        initialSearchParams,
        queuedQueries,
        queryRef: queryRef.current,
        stateRef: stateRef.current
      });
      stateRef.current = state;
      setInternalState(state);
    }
  }, [Object.values(resolvedUrlKeys).map((key) => `${key}=${initialSearchParams == null ? void 0 : initialSearchParams.get(key)}`).join("&"), JSON.stringify(queuedQueries)]);
  (0, import_react.useEffect)(() => {
    function updateInternalState(state) {
      debug("[nuq+ %s `%s`] updateInternalState %O", hookId, stateKeys, state);
      stateRef.current = state;
      setInternalState(state);
    }
    const handlers = Object.keys(keyMap).reduce((handlers$1, stateKey) => {
      handlers$1[stateKey] = ({ state, query }) => {
        const { defaultValue } = keyMap[stateKey];
        const urlKey = resolvedUrlKeys[stateKey];
        stateRef.current = {
          ...stateRef.current,
          [stateKey]: state ?? defaultValue ?? null
        };
        queryRef.current[urlKey] = query;
        debug("[nuq+ %s `%s`] Cross-hook key sync %s: %O (default: %O). Resolved: %O", hookId, stateKeys, urlKey, state, defaultValue, stateRef.current);
        updateInternalState(stateRef.current);
      };
      return handlers$1;
    }, {});
    for (const stateKey of Object.keys(keyMap)) {
      const urlKey = resolvedUrlKeys[stateKey];
      debug("[nuq+ %s `%s`] Subscribing to sync for `%s`", hookId, urlKey, stateKeys);
      emitter.on(urlKey, handlers[stateKey]);
    }
    return () => {
      for (const stateKey of Object.keys(keyMap)) {
        const urlKey = resolvedUrlKeys[stateKey];
        debug("[nuq+ %s `%s`] Unsubscribing to sync for `%s`", hookId, urlKey, stateKeys);
        emitter.off(urlKey, handlers[stateKey]);
      }
    };
  }, [stateKeys, resolvedUrlKeys]);
  const update = (0, import_react.useCallback)((stateUpdater, callOptions = {}) => {
    var _a, _b, _c, _d, _e, _f;
    const nullMap = Object.fromEntries(Object.keys(keyMap).map((key) => [key, null]));
    const newState = typeof stateUpdater === "function" ? stateUpdater(applyDefaultValues(stateRef.current, defaultValues)) ?? nullMap : stateUpdater ?? nullMap;
    debug("[nuq+ %s `%s`] setState: %O", hookId, stateKeys, newState);
    let returnedPromise = void 0;
    let maxDebounceTime = 0;
    const debounceAborts = [];
    for (let [stateKey, value] of Object.entries(newState)) {
      const parser = keyMap[stateKey];
      const urlKey = resolvedUrlKeys[stateKey];
      if (!parser) continue;
      if ((callOptions.clearOnDefault ?? parser.clearOnDefault ?? clearOnDefault) && value !== null && parser.defaultValue !== void 0 && (parser.eq ?? ((a, b) => a === b))(value, parser.defaultValue)) value = null;
      const query = value === null ? null : (parser.serialize ?? String)(value);
      emitter.emit(urlKey, {
        state: value,
        query
      });
      const update$1 = {
        key: urlKey,
        query,
        options: {
          history: callOptions.history ?? parser.history ?? history,
          shallow: callOptions.shallow ?? parser.shallow ?? shallow,
          scroll: callOptions.scroll ?? parser.scroll ?? scroll,
          startTransition: callOptions.startTransition ?? parser.startTransition ?? startTransition$1
        }
      };
      if (((_a = callOptions == null ? void 0 : callOptions.limitUrlUpdates) == null ? void 0 : _a.method) === "debounce" || (limitUrlUpdates == null ? void 0 : limitUrlUpdates.method) === "debounce" || ((_b = parser.limitUrlUpdates) == null ? void 0 : _b.method) === "debounce") {
        if (update$1.options.shallow === true) console.warn(error(422));
        const timeMs = ((_c = callOptions == null ? void 0 : callOptions.limitUrlUpdates) == null ? void 0 : _c.timeMs) ?? (limitUrlUpdates == null ? void 0 : limitUrlUpdates.timeMs) ?? ((_d = parser.limitUrlUpdates) == null ? void 0 : _d.timeMs) ?? defaultRateLimit.timeMs;
        const debouncedPromise = debounceController.push(update$1, timeMs, adapter);
        if (maxDebounceTime < timeMs) {
          returnedPromise = debouncedPromise;
          maxDebounceTime = timeMs;
        }
      } else {
        const timeMs = ((_e = callOptions == null ? void 0 : callOptions.limitUrlUpdates) == null ? void 0 : _e.timeMs) ?? ((_f = parser == null ? void 0 : parser.limitUrlUpdates) == null ? void 0 : _f.timeMs) ?? (limitUrlUpdates == null ? void 0 : limitUrlUpdates.timeMs) ?? callOptions.throttleMs ?? parser.throttleMs ?? throttleMs;
        debounceAborts.push(debounceController.abort(urlKey));
        globalThrottleQueue.push(update$1, timeMs);
      }
    }
    const globalPromise = debounceAborts.reduce((previous, fn) => fn(previous), globalThrottleQueue.flush(adapter, processUrlSearchParams));
    return returnedPromise ?? globalPromise;
  }, [
    stateKeys,
    history,
    shallow,
    scroll,
    throttleMs,
    limitUrlUpdates == null ? void 0 : limitUrlUpdates.method,
    limitUrlUpdates == null ? void 0 : limitUrlUpdates.timeMs,
    startTransition$1,
    resolvedUrlKeys,
    adapter.updateUrl,
    adapter.getSearchParamsSnapshot,
    adapter.rateLimitFactor,
    processUrlSearchParams,
    defaultValues
  ]);
  const outputState = (0, import_react.useMemo)(() => applyDefaultValues(internalState, defaultValues), [internalState, defaultValues]);
  return [outputState, update];
}
function parseMap(keyMap, urlKeys, searchParams, queuedQueries, cachedQuery, cachedState) {
  let hasChanged = false;
  const state = Object.keys(keyMap).reduce((out, stateKey) => {
    const urlKey = (urlKeys == null ? void 0 : urlKeys[stateKey]) ?? stateKey;
    const { parse } = keyMap[stateKey];
    const queuedQuery = queuedQueries[urlKey];
    const query = queuedQuery === void 0 ? (searchParams == null ? void 0 : searchParams.get(urlKey)) ?? null : queuedQuery;
    if (cachedQuery && cachedState && (cachedQuery[urlKey] ?? null) === query) {
      out[stateKey] = cachedState[stateKey] ?? null;
      return out;
    }
    hasChanged = true;
    const value = query === null ? null : safeParse(parse, query, stateKey);
    out[stateKey] = value ?? null;
    if (cachedQuery) cachedQuery[urlKey] = query;
    return out;
  }, {});
  if (!hasChanged) {
    const keyMapKeys = Object.keys(keyMap);
    const cachedStateKeys = Object.keys(cachedState ?? {});
    hasChanged = keyMapKeys.length !== cachedStateKeys.length || keyMapKeys.some((key) => !cachedStateKeys.includes(key));
  }
  return {
    state,
    hasChanged
  };
}
function applyDefaultValues(state, defaults) {
  return Object.fromEntries(Object.keys(state).map((key) => [key, state[key] ?? defaults[key] ?? null]));
}
function useQueryState(key, options = {}) {
  const { parse = (x) => x, serialize, eq, defaultValue, ...hookOptions } = options;
  const [{ [key]: state }, setState] = useQueryStates({ [key]: {
    parse,
    serialize,
    eq,
    defaultValue
  } }, hookOptions);
  const update = (0, import_react.useCallback)((stateUpdater, callOptions = {}) => setState((old) => ({ [key]: typeof stateUpdater === "function" ? stateUpdater(old[key]) : stateUpdater }), callOptions), [key, setState]);
  return [state, update];
}
export {
  createLoader,
  createParser,
  createSerializer,
  createStandardSchemaV1,
  debounce,
  defaultRateLimit,
  parseAsArrayOf,
  parseAsBoolean,
  parseAsFloat,
  parseAsHex,
  parseAsIndex,
  parseAsInteger,
  parseAsIsoDate,
  parseAsIsoDateTime,
  parseAsJson,
  parseAsNumberLiteral,
  parseAsString,
  parseAsStringEnum,
  parseAsStringLiteral,
  parseAsTimestamp,
  throttle,
  useQueryState,
  useQueryStates
};
//# sourceMappingURL=nuqs.js.map
