{"version":3,"file":"react-router-Ds1xL_ki.js","names":[],"sources":["../src/adapters/lib/react-router.ts"],"sourcesContent":["import {\n  startTransition,\n  useCallback,\n  useEffect,\n  useRef,\n  useState\n} from 'react'\nimport { debug } from '../../lib/debug'\nimport { createEmitter } from '../../lib/emitter'\nimport { setQueueResetMutex } from '../../lib/queues/reset'\nimport { globalThrottleQueue } from '../../lib/queues/throttle'\nimport { renderQueryString } from '../../lib/url-encoding'\nimport { createAdapterProvider, type AdapterProvider } from './context'\nimport type { AdapterInterface, AdapterOptions } from './defs'\nimport { applyChange, filterSearchParams } from './key-isolation'\nimport {\n  patchHistory as applyHistoryPatch,\n  historyUpdateMarker,\n  type SearchParamsSyncEmitterEvents\n} from './patch-history'\n\n// Abstract away the types for the useNavigate hook from react-router-based frameworks\ntype NavigateUrl = {\n  hash?: string\n  search?: string\n}\ntype NavigateOptions = {\n  replace?: boolean\n  preventScrollReset?: boolean\n  state?: unknown\n}\ntype NavigateFn = (url: NavigateUrl, options: NavigateOptions) => void\ntype UseNavigate = () => NavigateFn\ntype UseSearchParams = (initial: URLSearchParams) => [URLSearchParams, {}]\n\n// --\n\ntype CreateReactRouterBasedAdapterArgs = {\n  adapter: string\n  useNavigate: UseNavigate\n  useSearchParams: UseSearchParams\n}\n\nexport function createReactRouterBasedAdapter({\n  adapter,\n  useNavigate,\n  useSearchParams\n}: CreateReactRouterBasedAdapterArgs): {\n  NuqsAdapter: AdapterProvider\n  useOptimisticSearchParams: () => URLSearchParams\n} {\n  const emitter = createEmitter<SearchParamsSyncEmitterEvents>()\n  const enableQueueReset = adapter !== 'react-router-v6'\n  function useNuqsReactRouterBasedAdapter(\n    watchKeys: string[]\n  ): AdapterInterface {\n    const resetRef = useRef(false)\n    if (enableQueueReset && resetRef.current) {\n      resetRef.current = false\n      globalThrottleQueue.reset()\n    }\n\n    const navigate = useNavigate()\n    const searchParams = useOptimisticSearchParams(watchKeys)\n    const updateUrl = useCallback(\n      (search: URLSearchParams, options: AdapterOptions) => {\n        startTransition(() => {\n          emitter.emit('update', search)\n        })\n        const url = new URL(location.href)\n        url.search = renderQueryString(search)\n        debug(`[nuqs ${adapter}] Updating url: %s`, url)\n        // First, update the URL locally without triggering a network request,\n        // this allows keeping a reactive URL if the network is slow.\n        const updateMethod =\n          options.history === 'push' ? history.pushState : history.replaceState\n        setQueueResetMutex(options.shallow ? 1 : 2)\n        updateMethod.call(\n          history,\n          history.state, // Maintain the history state\n          historyUpdateMarker,\n          url\n        )\n        if (options.shallow === false) {\n          navigate(\n            {\n              // Somehow passing the full URL object here strips the search params\n              // when accessing the request.url in loaders.\n              hash: url.hash,\n              search: url.search\n            },\n            {\n              replace: true,\n              preventScrollReset: true,\n              state: history.state?.usr\n            }\n          )\n        }\n        if (options.scroll) {\n          window.scrollTo(0, 0)\n        }\n        resetRef.current = enableQueueReset\n      },\n      [navigate]\n    )\n    return {\n      searchParams,\n      updateUrl,\n      autoResetQueueOnUpdate: false\n    }\n  }\n  function useOptimisticSearchParams(\n    watchKeys: string[] = []\n  ): URLSearchParams {\n    const [serverSearchParams] = useSearchParams(\n      // Note: this will only be taken into account the first time the hook is called,\n      // and cached for subsequent calls, causing problems when mounting components\n      // after shallow updates have occurred.\n      typeof location === 'undefined'\n        ? new URLSearchParams()\n        : new URLSearchParams(location.search)\n    )\n    const [searchParams, setSearchParams] = useState(() => {\n      return typeof location === 'undefined'\n        ? // We use this on the server to SSR with the correct search params.\n          filterSearchParams(serverSearchParams, watchKeys, true)\n        : // Since useSearchParams isn't reactive to shallow changes,\n          // it doesn't pick up changes in the URL on mount, so we need to initialise\n          // the reactive state with the current URL instead.\n          filterSearchParams(\n            new URLSearchParams(location.search),\n            watchKeys,\n            false // No need for a copy here\n          )\n    })\n    useEffect(() => {\n      function onPopState() {\n        setSearchParams(\n          applyChange(new URLSearchParams(location.search), watchKeys, false)\n        )\n      }\n      function onEmitterUpdate(search: URLSearchParams) {\n        setSearchParams(applyChange(search, watchKeys, true))\n      }\n      emitter.on('update', onEmitterUpdate)\n      window.addEventListener('popstate', onPopState)\n      return () => {\n        emitter.off('update', onEmitterUpdate)\n        window.removeEventListener('popstate', onPopState)\n      }\n    }, [watchKeys.join('&')])\n    return searchParams\n  }\n  /**\n   * Sync shallow updates of the URL with the useOptimisticSearchParams hook.\n   *\n   * By default, the useOptimisticSearchParams hook will only react to internal nuqs updates.\n   * If third party code updates the History API directly, use this function to\n   * enable useOptimisticSearchParams to react to those changes.\n   *\n   * Note: this is actually required in React Router frameworks to follow Link navigations.\n   */\n  applyHistoryPatch(emitter, adapter)\n\n  return {\n    NuqsAdapter: createAdapterProvider(useNuqsReactRouterBasedAdapter),\n    useOptimisticSearchParams\n  }\n}\n"],"mappings":";;;;;;;;AA2CA,SAAgB,8BAA8B,EAC5C,SACA,aACA,mBAIA;CACA,MAAM,UAAU;CAChB,MAAM,mBAAmB,YAAY;CACrC,SAAS,+BACP,WACkB;EAClB,MAAM,WAAW,OAAO;AACxB,MAAI,oBAAoB,SAAS,SAAS;AACxC,YAAS,UAAU;AACnB,uBAAoB;;EAGtB,MAAM,WAAW;EACjB,MAAM,eAAe,0BAA0B;EAC/C,MAAM,YAAY,aACf,QAAyB,YAA4B;AACpD,yBAAsB;AACpB,YAAQ,KAAK,UAAU;;GAEzB,MAAM,MAAM,IAAI,IAAI,SAAS;AAC7B,OAAI,SAAS,kBAAkB;AAC/B,SAAM,SAAS,QAAQ,qBAAqB;GAG5C,MAAM,eACJ,QAAQ,YAAY,SAAS,QAAQ,YAAY,QAAQ;AAC3D,sBAAmB,QAAQ,UAAU,IAAI;AACzC,gBAAa,KACX,SACA,QAAQ,OACR,qBACA;AAEF,OAAI,QAAQ,YAAY,MACtB,UACE;IAGE,MAAM,IAAI;IACV,QAAQ,IAAI;MAEd;IACE,SAAS;IACT,oBAAoB;IACpB,OAAO,QAAQ,OAAO;;AAI5B,OAAI,QAAQ,OACV,QAAO,SAAS,GAAG;AAErB,YAAS,UAAU;KAErB,CAAC;AAEH,SAAO;GACL;GACA;GACA,wBAAwB;;;CAG5B,SAAS,0BACP,YAAsB,IACL;EACjB,MAAM,CAAC,sBAAsB,gBAI3B,OAAO,aAAa,cAChB,IAAI,oBACJ,IAAI,gBAAgB,SAAS;EAEnC,MAAM,CAAC,cAAc,mBAAmB,eAAe;AACrD,UAAO,OAAO,aAAa,cAEvB,mBAAmB,oBAAoB,WAAW,QAIlD,mBACE,IAAI,gBAAgB,SAAS,SAC7B,WACA;;AAGR,kBAAgB;GACd,SAAS,aAAa;AACpB,oBACE,YAAY,IAAI,gBAAgB,SAAS,SAAS,WAAW;;GAGjE,SAAS,gBAAgB,QAAyB;AAChD,oBAAgB,YAAY,QAAQ,WAAW;;AAEjD,WAAQ,GAAG,UAAU;AACrB,UAAO,iBAAiB,YAAY;AACpC,gBAAa;AACX,YAAQ,IAAI,UAAU;AACtB,WAAO,oBAAoB,YAAY;;KAExC,CAAC,UAAU,KAAK;AACnB,SAAO;;;;;;;;;;;AAWT,cAAkB,SAAS;AAE3B,QAAO;EACL,aAAa,sBAAsB;EACnC"}