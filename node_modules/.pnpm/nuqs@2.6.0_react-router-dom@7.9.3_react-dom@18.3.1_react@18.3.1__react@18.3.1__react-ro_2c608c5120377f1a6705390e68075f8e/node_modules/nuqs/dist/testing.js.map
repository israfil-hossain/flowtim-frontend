{"version":3,"file":"testing.js","names":["parsed: T"],"sources":["../src/testing.ts"],"sourcesContent":["import type { ParserBuilder } from './parsers'\n\n/**\n * Test that a parser is bijective (serialize then parse gives back the same value).\n *\n * It will throw if the parser does not serialize the input to the expected serialized value,\n * or if the parser does not parse the serialized value to the expected input value.\n * The parser's `eq` function (if provided, otherwise `===`) is used to compare the values.\n *\n * Usage:\n * ```ts\n * // Expect it to pass (no error thrown)\n * expect(isParserBijective(parseAsInteger, '42', 42)).toBe(true)\n * // Expect it to fail\n * expect(() => isParserBijective(parseAsInteger, '42', 47)).toThrow()\n * ```\n *\n * @param parser The parser to test\n * @param serialized The serialized representation of the input to test against\n * @param input An input value to test against\n * @returns `true` if the test passes, otherwise it will throw.\n */\nexport function isParserBijective<T>(\n  parser: ParserBuilder<T>,\n  serialized: string,\n  input: T\n): boolean {\n  // Test either sides of the bijectivitiy\n  testSerializeThenParse(parser, input)\n  testParseThenSerialize(parser, serialized)\n  // Test value equality\n  if (parser.serialize(input) !== serialized) {\n    throw new Error(\n      `[nuqs] parser.serialize does not match expected serialized value\n  Expected: '${serialized}'\n  Received: '${parser.serialize(input)}'\n  `\n    )\n  }\n  // @ts-expect-error - might return null\n  const parsed: T = parser.parse(serialized)\n  if (!parser.eq(parsed, input)) {\n    throw new Error(\n      `[nuqs] parser.parse does not match expected input value\n  Expected: ${input}\n  Received: ${parsed}\n  `\n    )\n  }\n  return true\n}\n\n/**\n * Test that a parser is bijective (serialize then parse gives back the same value).\n *\n * It will throw if the parser is not bijective (if the parsed value is not equal to the input value).\n * The parser's `eq` function is used to compare the values.\n *\n * Usage:\n * ```ts\n * // Expect it to pass (no error thrown)\n * expect(testSerializeThenParse(myParser, 'foo')).toBe(true)\n * // Expect it to fail\n * expect(() => testSerializeThenParse(myParser, 'bar')).toThrow()\n * ```\n *\n * @param parser The parser to test\n * @param input An input value to test against\n * @returns `true` if the test passes, otherwise it will throw.\n */\nexport function testSerializeThenParse<T>(\n  parser: ParserBuilder<T>,\n  input: T\n): boolean {\n  const serialized = parser.serialize(input)\n  const parsed = parser.parse(serialized)\n  if (parsed === null) {\n    throw new Error(\n      `[nuqs] testSerializeThenParse: parsed value is null (when parsing ${serialized} serialized from ${input})`\n    )\n  }\n  if (!parser.eq(input, parsed)) {\n    throw new Error(\n      `[nuqs] parser is not bijective (in testSerializeThenParse)\n  Expected value:         ${typeof input === 'object' ? JSON.stringify(input) : input}\n  Received parsed value:  ${typeof parsed === 'object' ? JSON.stringify(parsed) : parsed}\n  Serialized as: '${serialized}'\n  `\n    )\n  }\n  return true\n}\n\n/**\n * Tests that a parser is bijective (parse then serialize gives back the same query string).\n *\n * It will throw if the parser is not bijective (if the serialized value is not equal to the input query).\n *\n * Usage:\n * ```ts\n * // Expect it to pass (no error thrown)\n * expect(testParseThenSerialize(myParser, 'foo')).toBe(true)\n * // Expect it to fail\n * expect(() => testParseThenSerialize(myParser, 'bar')).toThrow()\n * ```\n *\n * @param parser The parser to test\n * @param input A query string to test against\n * @returns `true` if the test passes, otherwise it will throw.\n */\nexport function testParseThenSerialize<T>(\n  parser: ParserBuilder<T>,\n  input: string\n): boolean {\n  const parsed = parser.parse(input)\n  if (parsed === null) {\n    throw new Error(\n      `[nuqs] testParseThenSerialize: parsed value is null (when parsing ${input})`\n    )\n  }\n  const serialized = parser.serialize(parsed)\n  if (serialized !== input) {\n    throw new Error(\n      `[nuqs] parser is not bijective (in testParseThenSerialize)\n  Expected query: '${input}'\n  Received query: '${serialized}'\n  Parsed value: ${parsed}\n`\n    )\n  }\n  return true\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;AAsBA,SAAgB,kBACd,QACA,YACA,OACS;AAET,wBAAuB,QAAQ;AAC/B,wBAAuB,QAAQ;AAE/B,KAAI,OAAO,UAAU,WAAW,WAC9B,OAAM,IAAI,MACR;eACS,WAAW;eACX,OAAO,UAAU,OAAO;;CAKrC,MAAMA,SAAY,OAAO,MAAM;AAC/B,KAAI,CAAC,OAAO,GAAG,QAAQ,OACrB,OAAM,IAAI,MACR;cACQ,MAAM;cACN,OAAO;;AAInB,QAAO;;;;;;;;;;;;;;;;;;;;AAqBT,SAAgB,uBACd,QACA,OACS;CACT,MAAM,aAAa,OAAO,UAAU;CACpC,MAAM,SAAS,OAAO,MAAM;AAC5B,KAAI,WAAW,KACb,OAAM,IAAI,MACR,qEAAqE,WAAW,mBAAmB,MAAM;AAG7G,KAAI,CAAC,OAAO,GAAG,OAAO,QACpB,OAAM,IAAI,MACR;4BACsB,OAAO,UAAU,WAAW,KAAK,UAAU,SAAS,MAAM;4BAC1D,OAAO,WAAW,WAAW,KAAK,UAAU,UAAU,OAAO;oBACrE,WAAW;;AAI7B,QAAO;;;;;;;;;;;;;;;;;;;AAoBT,SAAgB,uBACd,QACA,OACS;CACT,MAAM,SAAS,OAAO,MAAM;AAC5B,KAAI,WAAW,KACb,OAAM,IAAI,MACR,qEAAqE,MAAM;CAG/E,MAAM,aAAa,OAAO,UAAU;AACpC,KAAI,eAAe,MACjB,OAAM,IAAI,MACR;qBACe,MAAM;qBACN,WAAW;kBACd,OAAO;;AAIvB,QAAO"}