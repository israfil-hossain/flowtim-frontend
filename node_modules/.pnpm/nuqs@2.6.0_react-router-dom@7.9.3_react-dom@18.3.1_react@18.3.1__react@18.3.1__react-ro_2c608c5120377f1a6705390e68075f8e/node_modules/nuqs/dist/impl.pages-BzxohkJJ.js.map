{"version":3,"file":"impl.pages-BzxohkJJ.js","names":["isNuqsUpdateMutex: boolean","searchParams","updateUrl: UpdateUrlFunction","out: Record<string, string | string[]>"],"sources":["../src/adapters/next/impl.pages.ts"],"sourcesContent":["import { useRouter } from 'next/compat/router.js'\nimport type { NextRouter } from 'next/router'\nimport { useCallback, useEffect, useMemo } from 'react'\nimport { debug } from '../../lib/debug'\nimport { resetQueues } from '../../lib/queues/reset'\nimport { globalThrottleQueue } from '../../lib/queues/throttle'\nimport { renderQueryString } from '../../lib/url-encoding'\nimport type { AdapterInterface, UpdateUrlFunction } from '../lib/defs'\n\ndeclare global {\n  interface Window {\n    next?: {\n      router?: NextRouter & {\n        state: {\n          asPath: string\n        }\n      }\n    }\n  }\n}\n\nexport function isPagesRouter(): boolean {\n  return typeof window.next?.router?.state?.asPath === 'string'\n}\n\nlet isNuqsUpdateMutex: boolean = false\n\nfunction onNavigation() {\n  if (isNuqsUpdateMutex) {\n    return\n  }\n  resetQueues()\n}\n\nexport function useNuqsNextPagesRouterAdapter(): AdapterInterface {\n  const router = useRouter()\n\n  useEffect(() => {\n    router?.events.on('routeChangeStart', onNavigation)\n    router?.events.on('beforeHistoryChange', onNavigation)\n    return () => {\n      router?.events.off('routeChangeStart', onNavigation)\n      router?.events.off('beforeHistoryChange', onNavigation)\n    }\n  }, [])\n\n  const searchParams = useMemo(() => {\n    const searchParams = new URLSearchParams()\n    if (router === null) {\n      return searchParams\n    }\n    for (const [key, value] of Object.entries(router.query)) {\n      if (typeof value === 'string') {\n        searchParams.set(key, value)\n      } else if (Array.isArray(value)) {\n        for (const v of value) {\n          searchParams.append(key, v)\n        }\n      }\n    }\n    return searchParams\n  }, [JSON.stringify(router?.query)])\n\n  const updateUrl: UpdateUrlFunction = useCallback((search, options) => {\n    // While the Next.js team doesn't recommend using internals like this,\n    // we need direct access to the pages router, as a bound/closured version from\n    // useRouter may be out of date by the time the updateUrl function is called,\n    // and would also cause updateUrl to not be referentially stable.\n    const nextRouter = window.next?.router!\n    const urlParams = extractDynamicUrlParams(\n      nextRouter.pathname,\n      nextRouter.query\n    )\n    const asPath =\n      getAsPathPathname(nextRouter.asPath) +\n      renderQueryString(search) +\n      location.hash\n    debug('[nuqs next/pages] Updating url: %s', asPath)\n    const method =\n      options.history === 'push' ? nextRouter.push : nextRouter.replace\n    isNuqsUpdateMutex = true\n    // A single requestAnimationFrame causes flakiness in the render count,\n    // but two nested ones seem to do the trick.\n    requestAnimationFrame(() =>\n      requestAnimationFrame(() => globalThrottleQueue.reset())\n    )\n    method\n      .call(\n        nextRouter,\n        // This is what makes the URL work (mapping dynamic segments placeholders\n        // in pathname to their values in query, plus search params in query too).\n        {\n          pathname: nextRouter.pathname,\n          query: {\n            // Note: we put search params first so that one that conflicts\n            // with dynamic params will be overwritten.\n            ...urlSearchParamsToObject(search),\n            ...urlParams\n          }\n          // For some reason we don't need to pass the hash here,\n          // it's preserved when passed as part of the asPath.\n        },\n        // This is what makes the URL pretty (resolved dynamic segments\n        // and nuqs-formatted search params).\n        asPath,\n        // And these are the options that are passed to the router.\n        {\n          scroll: options.scroll,\n          shallow: options.shallow\n        }\n      )\n      .finally(() => {\n        isNuqsUpdateMutex = false\n      })\n  }, [])\n\n  return {\n    searchParams,\n    updateUrl,\n    autoResetQueueOnUpdate: false\n  }\n}\n\nexport function getAsPathPathname(asPath: string): string {\n  return asPath\n    .replace(/#.*$/, '') // Remove hash\n    .replace(/\\?.*$/, '') // Remove search\n}\n\nexport function urlSearchParamsToObject(\n  search: URLSearchParams\n): Record<string, string | string[]> {\n  const out: Record<string, string | string[]> = {}\n  for (const key of search.keys()) {\n    const values = search.getAll(key)\n    if (values.length === 1) {\n      out[key] = values[0]!\n    } else if (values.length > 1) {\n      out[key] = values\n    }\n  }\n  return out\n}\n\n/**\n * Next.js pages router merges dynamic URL params with search params in its\n * internal state.\n * However, we need to pass just the URL params to the href part of the router\n * update functions.\n * This function finds the dynamic URL params placeholders in the pathname\n * (eg: `/path/[foo]/[bar]`) and extracts the corresponding values from the\n * query state object, leaving out any other search params.\n */\nexport function extractDynamicUrlParams(\n  pathname: string,\n  values: Record<string, string | string[] | undefined>\n): Record<string, string | string[] | undefined> {\n  const paramNames = new Set<string>()\n  const dynamicRegex = /\\[([^\\]]+)\\]/g\n  const catchAllRegex = /\\[\\.{3}([^\\]]+)\\]$/\n  const optionalCatchAllRegex = /\\[\\[\\.{3}([^\\]]+)\\]\\]$/\n\n  let match\n  while ((match = dynamicRegex.exec(pathname)) !== null) {\n    const paramName = match[1]\n    if (paramName) {\n      paramNames.add(paramName)\n    }\n  }\n  const dynamicValues = Object.fromEntries(\n    Object.entries(values).filter(([key]) => paramNames.has(key))\n  )\n  const matchCatchAll = catchAllRegex.exec(pathname)\n  if (matchCatchAll && matchCatchAll[1]) {\n    const key = matchCatchAll[1]\n    dynamicValues[key] = values[key] ?? []\n  }\n  const matchOptionalCatchAll = optionalCatchAllRegex.exec(pathname)\n  if (matchOptionalCatchAll && matchOptionalCatchAll[1]) {\n    const key = matchOptionalCatchAll[1]\n    // Note: while Next.js returns undefined if there are no values for the\n    // optional catch-all, passing undefined back when setting the state\n    // results in the value being set to an empty string.\n    // Passing an empty array instead results in the value remaining undefined.\n    dynamicValues[key] = values[key] ?? []\n  }\n  return dynamicValues\n}\n"],"mappings":";;;;;;;AAqBA,SAAgB,gBAAyB;AACvC,QAAO,OAAO,OAAO,MAAM,QAAQ,OAAO,WAAW;;AAGvD,IAAIA,oBAA6B;AAEjC,SAAS,eAAe;AACtB,KAAI,kBACF;AAEF;;AAGF,SAAgB,gCAAkD;CAChE,MAAM,SAAS;AAEf,iBAAgB;AACd,UAAQ,OAAO,GAAG,oBAAoB;AACtC,UAAQ,OAAO,GAAG,uBAAuB;AACzC,eAAa;AACX,WAAQ,OAAO,IAAI,oBAAoB;AACvC,WAAQ,OAAO,IAAI,uBAAuB;;IAE3C;CAEH,MAAM,eAAe,cAAc;EACjC,MAAMC,iBAAe,IAAI;AACzB,MAAI,WAAW,KACb,QAAOA;AAET,OAAK,MAAM,CAAC,KAAK,UAAU,OAAO,QAAQ,OAAO,OAC/C,KAAI,OAAO,UAAU,SACnB,gBAAa,IAAI,KAAK;WACb,MAAM,QAAQ,OACvB,MAAK,MAAM,KAAK,MACd,gBAAa,OAAO,KAAK;AAI/B,SAAOA;IACN,CAAC,KAAK,UAAU,QAAQ;CAE3B,MAAMC,YAA+B,aAAa,QAAQ,YAAY;EAKpE,MAAM,aAAa,OAAO,MAAM;EAChC,MAAM,YAAY,wBAChB,WAAW,UACX,WAAW;EAEb,MAAM,SACJ,kBAAkB,WAAW,UAC7B,kBAAkB,UAClB,SAAS;AACX,QAAM,sCAAsC;EAC5C,MAAM,SACJ,QAAQ,YAAY,SAAS,WAAW,OAAO,WAAW;AAC5D,sBAAoB;AAGpB,8BACE,4BAA4B,oBAAoB;AAElD,SACG,KACC,YAGA;GACE,UAAU,WAAW;GACrB,OAAO;IAGL,GAAG,wBAAwB;IAC3B,GAAG;;KAOP,QAEA;GACE,QAAQ,QAAQ;GAChB,SAAS,QAAQ;KAGpB,cAAc;AACb,uBAAoB;;IAEvB;AAEH,QAAO;EACL;EACA;EACA,wBAAwB;;;AAI5B,SAAgB,kBAAkB,QAAwB;AACxD,QAAO,OACJ,QAAQ,QAAQ,IAChB,QAAQ,SAAS;;AAGtB,SAAgB,wBACd,QACmC;CACnC,MAAMC,MAAyC;AAC/C,MAAK,MAAM,OAAO,OAAO,QAAQ;EAC/B,MAAM,SAAS,OAAO,OAAO;AAC7B,MAAI,OAAO,WAAW,EACpB,KAAI,OAAO,OAAO;WACT,OAAO,SAAS,EACzB,KAAI,OAAO;;AAGf,QAAO;;;;;;;;;;;AAYT,SAAgB,wBACd,UACA,QAC+C;CAC/C,MAAM,6BAAa,IAAI;CACvB,MAAM,eAAe;CACrB,MAAM,gBAAgB;CACtB,MAAM,wBAAwB;CAE9B,IAAI;AACJ,SAAQ,QAAQ,aAAa,KAAK,eAAe,MAAM;EACrD,MAAM,YAAY,MAAM;AACxB,MAAI,UACF,YAAW,IAAI;;CAGnB,MAAM,gBAAgB,OAAO,YAC3B,OAAO,QAAQ,QAAQ,QAAQ,CAAC,SAAS,WAAW,IAAI;CAE1D,MAAM,gBAAgB,cAAc,KAAK;AACzC,KAAI,iBAAiB,cAAc,IAAI;EACrC,MAAM,MAAM,cAAc;AAC1B,gBAAc,OAAO,OAAO,QAAQ;;CAEtC,MAAM,wBAAwB,sBAAsB,KAAK;AACzD,KAAI,yBAAyB,sBAAsB,IAAI;EACrD,MAAM,MAAM,sBAAsB;AAKlC,gBAAc,OAAO,OAAO,QAAQ;;AAEtC,QAAO"}